using Nitra;
using Nitra.Internal;
using Nitra.Runtime;
using Nitra.Serialization;

using Nemerle;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;

namespace Nitra.Compiler.Serialization
{
  internal class AstLifter : IAstLifter, ILifter[PExpr]
  {
    public static ContainerTypeName : string = "_N_LiftedAst";

    public this(manager : ManagerClass)
    {
      _manager = manager;
    }

    private         _manager     : ManagerClass;
    private mutable _containerTb : TypeBuilder;

    public Lift(ast : Ast) : string
    {
      def body = ast.Lift(this);

      when (_containerTb == null)
      {
        def env = _manager.CoreEnv.EnterIntoNamespace(["Nitra", "Internal"]);
        _containerTb = env.Define(<[ decl: internal module $(ContainerTypeName : usesite) {} ]>);
      }

      def key = Util.tmpname("ast");

      _containerTb.DefineConditional(<[ decl:
        public $(key : usesite)(context : Nitra.Runtime.ChemicalAstContext) : Nitra.Ast
        {
          $body;
        }
      ]>);

      key
    }

    public Emit() : void
    {
      when (_containerTb : object != null)
        _containerTb.Compile();
    }

    public AmbiguousAst(ruleDescriptor : RuleDescriptor, location : Nitra.Location, alternatives : array[PExpr]) : PExpr
    {
      _ = ruleDescriptor; _ = location; _ = alternatives;
      throw System.NotImplementedException()
    }

    public MissingAst(ruleDescriptor : RuleDescriptor, location : Nitra.Location) : PExpr
    {
      _ = ruleDescriptor; _ = location;
      throw System.NotImplementedException()
    }

    public Ast(ruleDescriptor : RuleDescriptor, location : Nitra.Location, types : array[LiftType], members : array[PExpr]) : PExpr
    {
      _ = location;

      def filteredMembers = List();
      foreach (m in members with index)
        unless (IsOptimized(types[index]))
          filteredMembers.Add(m);

      def astTypeName = PExprUtils.FromQualifiedIdentifier(NString.Split(ruleDescriptor.Grammar.FullName + "." + ruleDescriptor.Name, '.'));
      <[ $astTypeName.Create(context, ..$filteredMembers) ]>
    }

    public Text(source : SourceSnapshot, span : NSpan) : PExpr
    {
      <[ $(source.Text.Substring(span.StartPos, span.Length) : string) ]>
    }

    public Keyword(source : SourceSnapshot, span : NSpan, keyword : string) : PExpr
    {
      _ = source; _ = span; _ = keyword;
      <[ () ]>
    }

    public List(itemType : LiftType, items : List[PExpr]) : PExpr
    {
      if (IsOptimized(itemType))
        <[ $(items.Count : int) ]>
      else
        <[ [..$items] ]>
    }

    public Option(itemType : LiftType, item : option[PExpr]) : PExpr
    {
      if (IsOptimized(itemType))
        match (item)
        {
          | Some => <[ true ]>
          | None => <[ false ]>
        }
      else
        match (item)
        {
          | Some(value) => <[ Some($value) ]>
          | None        => <[ None() ]>
        }
    }

    public Tuple(types : array[LiftType], members : array[PExpr]) : PExpr
    {
      def filteredMembers = List();
      foreach (m in members with index)
        unless (IsOptimized(types[index]))
          filteredMembers.Add(m);

      match (filteredMembers.Count)
      {
        | 0 => <[ () ]>
        | 1 => filteredMembers[0]
        | _ => <[ (..$filteredMembers) ]>
      }
    }

    private static IsOptimized(type : LiftType) : bool
    {
      | Keyword => true
      | Text
      | Ast => false
      | List(type)
      | Option(type) => IsOptimized(type)
      | Tuple(items) => items.All(IsOptimized)
    }
  }
}
