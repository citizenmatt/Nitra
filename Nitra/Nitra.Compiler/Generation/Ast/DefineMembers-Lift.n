using Nemerle;
using Nemerle.Collections;
using Nemerle.Imperative;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Compiler.Typedtree;

using Nitra.Internal;
using Nitra.Model;
using Nitra.Typing;

using System;
using System.Diagnostics;
using System.Linq;
using SCG = System.Collections.Generic;

namespace Nitra.Compiler
{
  internal partial class RuleAstEmitter
  {
    private DefineAstLift(fields : SCG.List[FieldInfo]) : void
    {
      _astTb.DefineConditional(<[ decl:
        public override Lift[T](lifter : Nitra.Internal.ILifter[T]) : T
        {
          lifter.Ast($(this.RuleSymbol.GetRuleDescriptorRef()), this.Location, array[]);
        }
      ]>);
    }

    private DefineMissingLift() : void
    {
      _missingTb.DefineConditional(<[ decl:
        public override Lift[T](lifter : Nitra.Internal.ILifter[T]) : T
        {
          lifter.MissingAst($(this.RuleSymbol.GetRuleDescriptorRef()), this.Location);
        }
      ]>);
    }

    private DefineAmbiguousLift() : void
    {
      _ambiguousTb.DefineConditional(<[ decl:
        public override Lift[T](lifter : Nitra.Internal.ILifter[T]) : T
        {
          def alternatives = array(this.Ambiguities.Length);
          for(mutable i = 0; i < alternatives.Length; ++i)
            alternatives[i] = this.Ambiguities[i].Lift(lifter);
          lifter.AmbiguousAst($(this.RuleSymbol.GetRuleDescriptorRef()), this.Location, alternatives);
        }
      ]>);
    }

    private DefineSpliceLift() : void
    {
      _spliceTb.DefineConditional(<[ decl:
        public override Lift[T](_ : Nitra.Internal.ILifter[T]) : T
        {
          throw System.NotSupportedException()
        }
      ]>);
    }
  }
}
