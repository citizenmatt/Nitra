using Nemerle;
using Nemerle.Collections;
using Nemerle.Imperative;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Compiler.Typedtree;

using Nitra.Internal;
using Nitra.Model;
using Nitra.Typing;

using System;
using System.Diagnostics;
using System.Linq;
using SCG = System.Collections.Generic;

namespace Nitra.Compiler
{
  internal partial class RuleAstEmitter
  {
    public DefineMembers() : void
    {
      when (_baseTb != null)
      {
        DefineBaseAstCreateMethod();
        DefineBaseAstRuleMethods();
      }
      when (_astTb != null)
      {
        def fields = GetFields();
        DefineAstCtorAndFields(fields);
        DefineParsedAstCtorAndFields(fields);
        DefineChemicalAstCtorAndFields(fields);
        DefineAstPrettyPrint();
        DefineAstRuleMethods();
        DefineAstLift(fields);
      }
      when (_spliceTb != null)
      {
        DefineSpliceRuleMethods();
        DefineSpliceLift();
      }
      when (_missingTb != null)
      {
        DefineMissingPrettyPrint();
        DefineMissingRuleMethods();
        DefineMissingLift();
      }
      when (_ambiguousTb != null)
      {
        DefineAmbiguousPrettyPrint();
        DefineAmbiguousRuleMethods();
        DefineAmbiguousLift();
      }
    }

    private DefineBaseAstCreateMethod() : void
    {
      when (this.RuleSymbol is SimpleRuleSymbol)
      {
        _baseTb.DefineConditional(<[ decl:
          public static Create(pos : ref int, parseResult : Nitra.Internal.ParseResult) : $(_baseTb.GetMemType() : typed)
          {
            def ruleParser = parseResult.RuleParser.Grammar.GetSimpleRuleParser($(this.RuleSymbol.GetRuleDescriptorRef()));
            def astPtr = parseResult.TryGetAst(pos, ruleParser.RuleId);
            if (astPtr > 0)
              $(_baseTb.GetMemType() : typed).__Parsed__Ast(ref pos, astPtr, parseResult)
            else
              $(_baseTb.GetMemType() : typed).MissingAst(parseResult, pos)
          }
        ]>);
      }
      when (this.RuleSymbol.Options.IsStart)
      {
        match (this.RuleSymbol)
        {
          | SimpleRuleSymbol =>
            _baseTb.DefineConditional(<[ decl:
              public static Create(parseResult : Nitra.Internal.ParseResult) : $(_baseTb.GetMemType() : typed)
              {
                mutable pos = parseResult.StartPos;
                Create(ref pos, parseResult);
              }
            ]>);

          | ExtensibleRuleSymbol =>
            _baseTb.DefineConditional(<[ decl:
              public static Create(parseResult : Nitra.Internal.ParseResult) : $(_baseTb.GetMemType() : typed)
              {
                mutable pos = parseResult.StartPos;
                Nitra.Internal.ExtensibleRuleAstConstructor.Create(ref pos, parseResult, 0, $(this.RuleSymbol.GetRuleDescriptorRef()));
              }
            ]>);

          | _ => assert2(false);
        }
      }
    }

    private DefineAstCtorAndFields(fields : SCG.List[FieldInfo]) : void
    {
      foreach (field in fields)
      {
        _astTb.DefineConditional(<[ decl:
          public new abstract $(field.Name : usesite) : $(field.Type : typed)
          {
            get;
          }
        ]>);
      }
    }

    private DefineParsedAstCtorAndFields(fields : SCG.List[FieldInfo]) : void
    {
      _parsedAstTb.DefineConditional(<[ decl: private parseResult : Nitra.Internal.ParseResult; ]>);
      _parsedAstTb.DefineConditional(<[ decl: private startPos    : int; ]>);
      _parsedAstTb.DefineConditional(<[ decl: private endPos      : int; ]>);
      _parsedAstTb.DefineConditional(<[ decl: private astPtr      : int; ]>);

      _parsedAstTb.DefineConditional(<[ decl:
        public override Location : Nitra.Location
        {
          get { Nitra.Location(this.parseResult.OriginalSource, this.startPos, this.endPos) }
        }
      ]>);

      _parsedAstTb.DefineConditional(<[ decl:
        protected override PrettyPrintSource : Nitra.IPrettyPrintSource
        {
          get { this.parseResult }
        }
      ]>);

      def astPtr = AstPointer.Existing(this.RuleSymbol.Sequence, this, "astPtr");

      def endPosExpr = this.RuleSymbol.Sequence.NonMarkerSubrules.Fold(<[ pos ]>, (subrule, acc) => <[ $acc + $(astPtr.GetSize(subrule)) ]>);

      match (this.RuleSymbol)
      {
        | SimpleRuleSymbol
        | ExtensionRuleSymbol(ExtensionType = Prefix) =>
          _parsedAstTb.DefineConditional(<[decl:
            public this(pos : ref int, astPtr : int, parseResult : Nitra.Internal.ParseResult)
            {
              unchecked
              {
                this.parseResult = parseResult;
                this.startPos    = pos;
                this.endPos      = $endPosExpr;
                this.astPtr      = astPtr;
                pos              = this.endPos;
              }
            }
          ]>);

        | ExtensionRuleSymbol(ExtensionType = Postfix) as symbol =>
          _parsedAstTb.DefineConditional(<[ decl: private astStartPos : int; ]>);
          _parsedAstTb.DefineConditional(<[ decl: private prefix      : $(Environment.GetAstType(symbol.BaseRule.Value) : typed); ]>);
          _parsedAstTb.DefineConditional(<[ decl:
            public this(prefix : $(Environment.GetAstType(symbol.BaseRule.Value) : typed), prefixStartPos : int, pos : ref int, astPtr : int, parseResult : Nitra.Internal.ParseResult)
            {
              unchecked
              {
                this.parseResult = parseResult;
                this.startPos    = prefixStartPos;
                this.endPos      = $endPosExpr;
                this.astPtr      = astPtr;
                this.astStartPos = pos;
                this.prefix      = prefix;
                pos              = this.endPos;
              }
            }
          ]>);

        | _ => assert(false)
      }

      foreach (field in fields)
      {
        def statements = SCG.List();

        mutable needRuleParser  : bool;
        mutable needCaching     : bool;

        def analyze(_ : FieldExpr) : void
        {
          | Prefix         => ()
          | Tuple(items)   => foreach (expr in items) analyze(expr);
          | Chars(_, true) => needRuleParser = true;
          | Chars          => ()
          | Other(_, true) => needRuleParser = true; needCaching = true;
          | Other          =>                        needCaching = true;
        }

        analyze(field.Expr);

        when (needRuleParser)
          statements.Add(<[ def ruleParser = parseResult.GetRuleParser(astPtr) :> $(this.RuleSymbol.GetParserClassRef()) ]>);

        def compile(_ : FieldExpr) : PExpr
        {
          | Prefix(expr)
          | Chars(expr, _)
          | Other(expr, _) => expr
          | Tuple(items)   => <[ (..$(items.Map(compile))) ]>
        }

        statements.Add(compile(field.Expr));

        def code =
          if (needCaching)
          {
            def backingFieldName = Util.tmpname(field.Name);
            _parsedAstTb.DefineConditional(<[ decl: private mutable $(backingFieldName : usesite) : $(field.Type : typed); ]>);
            if (field.Type.IsValueType)
            {
              def loadedBit = _parsedAstTb.GetBitFieldManager().Allocate();
              <[
                unless ($(loadedBit.Read()))
                {
                  $(backingFieldName : usesite) = { ..$statements };
                  $(loadedBit.Set());
                }
                $(backingFieldName : usesite)
              ]>
            }
            else
            {
              <[
                when ($(backingFieldName : usesite) : object == null)
                {
                  $(backingFieldName : usesite) = { ..$statements };
                }
                $(backingFieldName : usesite)
              ]>
            }
          }
          else
            <[ { ..$statements } ]>;

        _parsedAstTb.DefineConditional(<[ decl:
          public override $(field.Name : usesite) : $(field.Type : typed)
          {
            get { unchecked ($code) }
          }
        ]>);
      }
    }

    private DefineChemicalAstCtorAndFields(fields : SCG.List[FieldInfo]) : void
    {
      def traverse(ruleType : RuleType, variable : string) : FixedType * bool * PExpr
      {
        match (ruleType)
        {
          | Void                 => assert3(false)
          | Ref(symbol)          => (Environment.GetAstType(symbol), true,  <[ $(variable : usesite) ]>)
          | Chars(Some(keyword)) => (FixedType.Void(),               false, <[ context.GetKeywordSpan($(keyword : string)) ]>)
          | Chars(None)          => (Environment.StringTypeVar,      false, <[ context.GetSpan($(variable : usesite)) ]>)
          | Option(type) =>
            def itemVariable = Util.tmpname("item");
            def (itemInputType, isUnchanged, itemExpr) = traverse(type, itemVariable);
            if (isUnchanged)
              (FixedType.Class(Environment.OptionTypeInfo, [itemInputType]), true, <[ $(variable : usesite) ]>);
            else if (itemInputType is FixedType.Void)
              (Environment.BooleanTypeVar, false, <[ if ($(variable : usesite)) Some($itemExpr) else None(); ]>)
            else
            {
              def expr =
              <[
                match ($(variable : usesite))
                {
                  | Some($(itemVariable : usesite)) => Some($itemExpr)
                  | None                            => None()
                }
              ]>;
              (FixedType.Class(Environment.OptionTypeInfo, [itemInputType]), false, expr)
            }

          | List(type) =>
            def itemVariable = Util.tmpname("item");
            def (itemInputType, isUnchanged, itemExpr) = traverse(type, itemVariable);
            if (isUnchanged)
              (FixedType.Class(Environment.ListTypeInfo, [itemInputType]), true, <[ $(variable : usesite) ]>);
            else if (itemInputType is FixedType.Void)
            {
              def expr =
              <[
                def items = array($(variable : usesite));
                for (mutable i = 0; i < items.Length; ++i)
                  items[i] = $itemExpr;
                Nemerle.Collections.NList.ToList(items);
              ]>;
              (Environment.Int32TypeVar, false, expr)
            }
            else
            {
              def expr =
              <[
                def items = System.Collections.Generic.List();
                foreach ($(itemVariable : usesite) in $(variable : usesite))
                  items.Add($itemExpr);
                Nemerle.Collections.NList.ToList(items);
              ]>;
              (FixedType.Class(Environment.ListTypeInfo, [itemInputType]), false, expr)
            }

          | Tuple(types) =>
            def memberInputTypes   = SCG.List();
            def patternVariables   = SCG.List();
            def exprs              = SCG.List();
            mutable isAllUnchanged = true;

            foreach(t in types)
            {
              def memberVariable = Util.tmpname("member");
              def (memberType, isUnchanged, memberExpr) = traverse(t, memberVariable);
              isAllUnchanged &= isUnchanged;
              unless (memberType is FixedType.Void)
              {
                memberInputTypes.Add(memberType);
                patternVariables.Add(memberVariable);
              }
              exprs.Add(memberExpr);
            }

            if (isAllUnchanged)
              (FixedType.Tuple(memberInputTypes.MapToList(x => x)), true, <[ $(variable : usesite) ]>)
            else
              match (memberInputTypes.Count)
              {
                | 0 => (FixedType.Void(), false, <[ (..$exprs) ]>)
                | 1 => (memberInputTypes[0], false, <[ def $(patternVariables[0] : usesite) = $(variable : usesite); (..$exprs) ]>)
                | _ => (FixedType.Tuple(memberInputTypes.MapToList(x => x)), false, <[ def (..$(patternVariables.MapToList(name => <[ $(name : usesite) ]>))) = $(variable : usesite); (..$exprs) ]>)
              }
        }
      }

      _chemicalAstTb.DefineConditional(<[ decl:
        private context : Nitra.Runtime.ChemicalAstContext;
      ]>);
      _chemicalAstTb.DefineConditional(<[ decl:
        public override Location : Nitra.Location
        {
          get { Nitra.Location(context.GetSource(), 0, 0) }
        }
      ]>);

      def parameters = SCG.List();
      parameters.Add(<[ parameter: context : Nitra.Runtime.ChemicalAstContext ]>);

      def statements = SCG.List();
      statements.Add(<[ this.context = context; ]>);

      foreach (field in fields)
      {
        _chemicalAstTb.DefineConditional(<[ decl:
          public override $(field.Name : usesite) : $(field.Type : typed) { get; }
        ]>);

        def (parameterType, _, expr) = traverse(field.Rule.Type, field.Name);
        unless (parameterType is FixedType.Void)
          parameters.Add(<[ parameter: $(field.Name : usesite) : $(parameterType : typed) ]>);
        statements.Add(<[ this.$(field.Name : usesite) = $expr ]>);
      }

      _chemicalAstTb.DefineConditional(<[ decl:
        public this(..$parameters) { unchecked { ..$statements } }
      ]>);

      match (this.RuleSymbol)
      {
        | SimpleRuleSymbol    with tb = _baseTb
        | ExtensionRuleSymbol with tb = _astTb =>
          tb.DefineConditional(<[ decl:
            public static Create(..$parameters) : $(_astTb.GetMemType() : typed)
            {
              $(_chemicalAstTb.GetMemType() : typed)(..$(parameters.Map(_.ReferencingExpr)));
            }
          ]>);

        | _ => assert3(false)
      }
    }
  }
}
