using Nitra.Model;
using Nitra.ProjectSystem;

using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;

namespace Nitra.Typing
{
  public sealed class SyntaxModuleBodyContext : EnteredScopeContext, ITokenNamesMapContext, IRuleAliasMapContext
  {
    public this(parent : Context)
    {
      base(parent);
    }

    public override CurrentSymbols : list[Symbol] { get { [] } }

    public TokenNamesMap : Map[string, TokenLiteralSymbol]
    {
      get { GetSymbolMaps()[0] }
    }

    public RuleAliasMap : Map[string, RuleAliasSymbol]
    {
      get { GetSymbolMaps()[1] }
    }

    public GetSpaceRule(context : Context, ruleName : string, loc : Location) : option[RuleDefSymbol]
    {
      def result = GetSpaceRule(context, ruleName);
      when (result.IsNone && !_whitespaceHintShown)
      {
        NitraProject.CurrentProject.Hint(loc, $"Declare whitespace handling rule '$ruleName' or import 'Whitespaces' syntax module from Nitra.Core library.", -1);
        _whitespaceHintShown = true;
      }
      result;
    }

    [Memoize]
    private GetSpaceRule(context : Context, ruleName : string) : option[RuleDefSymbol]
    {
      def s = Location(SourceSnapshot(ruleName, 0, ""), NSpan(0, ruleName.Length));
      def symbol = Utils.BindImpl(context.BindMany.[RuleDefSymbol](s));
      symbol
    }

    [Memoize]
    private GetSymbolMaps() : Map[string, TokenLiteralSymbol] * Map[string, RuleAliasSymbol]
    {
      def appendTokenLiteralSymbol(symbol : TokenLiteralSymbol, map : Map[string, TokenLiteralSymbol])
      {
        symbol.StringLiterals.FoldLeft(map, (lit, map) => map.Replace(lit, symbol))
      }
      def appendRuleAliasSymbol(symbol : RuleAliasSymbol, map : Map[string, RuleAliasSymbol])
      {
        map.Replace(symbol.Name, symbol)
      }
      def walk(baseContext)
      {
        match (baseContext.TryGetParent.[OpenNamespaceOrTypeContext]())
        {
          | null => (Map(), Map())
          | OpenNamespaceOrTypeContext(OpenSymbol = Some(SyntaxModuleSymbol as moduleSymbol)) as context =>
            def (tokenLiteralMap, ruleAliasMap) = walk(context);
            def newTokenLiteralMap = moduleSymbol.TokenLiterals.FoldLeft(tokenLiteralMap, appendTokenLiteralSymbol);
            def newRuleAliasMap    = moduleSymbol.RuleAliases.FoldLeft(ruleAliasMap, appendRuleAliasSymbol);
            (newTokenLiteralMap, newRuleAliasMap)

          | context => walk(context)
        }
      }
      walk(this)
    }

    private mutable _whitespaceHintShown : bool = false;

    public override ToString() : string
    {
      "<SyntaxModuleBodyContext>"
    }
  }
}
