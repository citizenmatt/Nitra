using Nemerle;
using Nemerle.Collections;
using Nemerle.Imperative;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Compiler.Typedtree;

using Nitra.Internal;
using Nitra.Model;
using Nitra.Typing;

using System;
using System.Diagnostics;
using System.Linq;
using SCG = System.Collections.Generic;

namespace Nitra.Compiler
{
  internal partial class RuleAstEmitter
  {
    private DefineAstLift(fields : SCG.List[FieldInfo]) : void
    {
      def body = SCG.List();
      def liftTypeNameCache = SCG.Dictionary();
      def getLiftType(ruleType : RuleType) : PExpr
      {
        | Void             => assert(false);
        | Ref              => <[ Nitra.Internal.LiftType.Ast() ]>
        | Chars(Some)      => <[ Nitra.Internal.LiftType.Keyword() ]>
        | Chars(None)      => <[ Nitra.Internal.LiftType.Text() ]>
        | List(itemType)   =>
          mutable name : string;
          unless (liftTypeNameCache.TryGetValue(ruleType, out name))
          {
            name = Util.tmpname("liftType_List");
            body.Add(<[ def $(name : usesite) = Nitra.Internal.LiftType.List($(getLiftType(itemType))); ]>);
            liftTypeNameCache.Add(ruleType, name);
          }
          <[ $(name : usesite) ]>

        | Option(itemType) =>
          mutable name : string;
          unless (liftTypeNameCache.TryGetValue(ruleType, out name))
          {
            name = Util.tmpname("liftType_Option");
            body.Add(<[ def $(name : usesite) = Nitra.Internal.LiftType.Option($(getLiftType(itemType))); ]>);
            liftTypeNameCache.Add(ruleType, name);
          }
          <[ $(name : usesite) ]>

        | Tuple(members)   =>
          mutable name : string;
          unless (liftTypeNameCache.TryGetValue(ruleType, out name))
          {
            name = Util.tmpname("liftType_Tuple");
            body.Add(<[ def $(name : usesite) = Nitra.Internal.LiftType.Tuple(array[..$(members.Map(getLiftType))]); ]>);
            liftTypeNameCache.Add(ruleType, name);
          }
          <[ $(name : usesite) ]>
      }

      def lift(ruleType : RuleType, target : PExpr) : PExpr
      {
        match (ruleType)
        {
          | Void                 => assert(false)
          | Ref                  => <[ $target.Lift(lifter) ]>
          | Chars(Some(keyword)) => <[ lifter.Keyword(this.Location.Source, $target, $keyword) ]>
          | Chars(None)          => <[ lifter.Text(this.Location.Source, $target) ]>
          | Option(itemType) =>
            <[
              match ($target)
              {
                | Some(x) => lifter.Option($(getLiftType(itemType)), Some($(lift(itemType, <[ x ]>))))
                | None    => lifter.Option($(getLiftType(itemType)), None())
              }
            ]>

          | Tuple(members) =>
            def vars = members.Map(t => (t, Util.tmpname("item")));
            def decls = vars.Map((_, n) => <[ $(n : usesite) ]>);
            def lifts = vars.Map((t, n) => lift(t, <[ $(n : usesite) ]>));
            <[
              def (..$decls) = $target;
              lifter.Tuple(array[..$(members.Map(getLiftType))], array[..$lifts])
            ]>

          | List(itemType) =>
            <[
              def items = System.Collections.Generic.List();
              foreach (x in $target)
                items.Add($(lift(itemType, <[ x ]>)));
              lifter.List($(getLiftType(itemType)), items);
            ]>
        }
      }

      def members = SCG.List();
      def liftTypes = SCG.List();
      foreach (f in fields)
      {
        members.Add(lift(f.Rule.Type, <[ this.$(f.Name : usesite) ]>));
        liftTypes.Add(getLiftType(f.Rule.Type));
      }

      body.Add(<[ lifter.Ast($(this.RuleSymbol.GetRuleDescriptorRef()), this.Location, array[..$liftTypes], array[..$members]) ]>);

      _astTb.DefineConditional(<[ decl:
        public override Lift[T](lifter : Nitra.Internal.ILifter[T]) : T
        {
          unchecked { ..$body }
        }
      ]>);
    }

    private DefineMissingLift() : void
    {
      _missingTb.DefineConditional(<[ decl:
        public override Lift[T](lifter : Nitra.Internal.ILifter[T]) : T
        {
          unchecked { lifter.MissingAst($(this.RuleSymbol.GetRuleDescriptorRef()), this.Location); }
        }
      ]>);
    }

    private DefineAmbiguousLift() : void
    {
      _ambiguousTb.DefineConditional(<[ decl:
        public override Lift[T](lifter : Nitra.Internal.ILifter[T]) : T
        {
          unchecked
          {
            def alternatives = array(this.Ambiguities.Length);
            for(mutable i = 0; i < alternatives.Length; ++i)
              alternatives[i] = this.Ambiguities[i].Lift(lifter);
            lifter.AmbiguousAst($(this.RuleSymbol.GetRuleDescriptorRef()), this.Location, alternatives);
          }
        }
      ]>);
    }

    private DefineSpliceLift() : void
    {
      _spliceTb.DefineConditional(<[ decl:
        public override Lift[T](_ : Nitra.Internal.ILifter[T]) : T
        {
          throw System.NotSupportedException()
        }
      ]>);
    }
  }
}
