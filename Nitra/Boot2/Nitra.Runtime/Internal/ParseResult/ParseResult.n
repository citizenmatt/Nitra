using Nitra.Runtime;
using Nitra.Runtime.Reflection;

using Nemerle;
using Nemerle.Imperative;
using Nemerle.Imperative.GoTo;
using Nemerle.Collections;
using Nemerle.Late;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Diagnostics;
using System.Linq;
using System.Collections.ObjectModel;

using System.Text;
using SCG = System.Collections.Generic;

namespace Nitra.Internal
{
  public partial class ParseResult : IPrettyPrintSource, ISourceSnapshotProvider
  {
    public static AstParsedState = ~int.MaxValue;

    public static ResultOffset = 0;

    public         Text             : string         { get; }
    public mutable ast              : array[int];
    public mutable memoize          : array[int];
    public mutable allocated        : int;
    public mutable TerminateParsing : bool; // may be volatile?
    public         ParserHost       : ParserHost;
    public         OriginalSource   : SourceSnapshot { get; }
    public         StartPos         : int            { get; }
    public         RuleParser       : RuleParser     { get; }
    public mutable LastParseStart   : int;
    public mutable LastParseEnd     : int;
    public         RecoveryStacks   : SCG.List[RecoveryStackFrame];
    public         ErrorData        : SCG.List[ParseErrorData];
    private mutable _maxFailPos     : int;
    private mutable _counter        : int;
    private _errors                 : SCG.List[Error] = SCG.List();

    public this(source : SourceSnapshot, startPos : int, initalSize : int, parserHost : ParserHost, ruleParser : RuleParser)
    {
      Text             = source.Text;
      OriginalSource   = source;
      StartPos         = startPos;
      TokenEnumerator1 = TokenEnumerator(this);
      TokenEnumerator2 = TokenEnumerator(this);
      ErrorData        = SCG.List();
      RecoveryStacks   = SCG.List();
      this.ast         = array(if (initalSize < 10) 10 else initalSize);
      this.memoize     = array(Text.Length + 1);
      this.allocated   = 0;
      this.ParserHost  = parserHost;
      LastParseStart   = -1;
      LastParseEnd     = -1;
      MaxFailPos       = 0;
      this.RuleParser  = ruleParser;
    }

    public static AddMandatoryTokens(mt1 : int, mt2 : int) : int
    {
      if (mt1 < 0) if (mt2 < 0) ~(~mt1 + ~mt2)
                   else         ~(~mt1 +  mt2)
      else         if (mt2 < 0) ~( mt1 + ~mt2)
                   else          ( mt1 +  mt2)
    }

    public GenerateId() : int
    {
      _counter++;
      _counter
    }
    
    public MaxFailPos : int
    {
      get { _maxFailPos }
      set { _maxFailPos = value }
    }

    public IsSuccess : bool { get { ErrorData.Count == 0 } }
    
    public TokenEnumerator1 : TokenEnumerator;
    public TokenEnumerator2 : TokenEnumerator;

    public DebugText : string
    {
      get
      {
        def sb1 = StringBuilder();
        def sb2 = StringBuilder();
        def sb3 = StringBuilder();
        def appendIndex(len : int, i : int)
        {
          _ = sb3.Append(('0' + (i / 10)) :> char, len);
          _ = sb2.Append(('0' + (i % 10)) :> char, len);
        }
        def addEsc(ch : string, i : int) : void
        {
          def str = $@"\$ch";
          _ = sb1.Append(str);
          appendIndex(str.Length, i);
        }
        foreach (ch in Text with i)
        {
          | '\"'      => addEsc("\"", i)
          | '\\'      => addEsc("\\", i)
          | '\n'      => addEsc("n", i)
          | '\t'      => addEsc("t", i)
          | '\r'      => addEsc("r", i)
          | '\e'      => addEsc("e", i)
          | '\a'      => addEsc("a", i)
          | '\b'      => addEsc("b", i)
          | '\f'      => addEsc("f", i)
          | '\v'      => addEsc("v", i)
          | '\0'      => addEsc("0", i)
          | '\uFFFF'  => addEsc("uFFFF", i)
          | c         => _ = sb1.Append(c); appendIndex(1, i)
          
        }
        
        sb1.AppendLine().Append(sb2.ToString()).AppendLine().Append(sb3.ToString()).ToString()
      }
    }
    
    public ParseResult : string
    {
      get
      {
        if (LastParseEnd >= 0)
          Text.Substring(LastParseStart, LastParseEnd - LastParseStart)
        else
          "<fail>"
      }
    }

    public RestText : string
    {
      get { Text.Substring(if (LastParseEnd >= 0) LastParseEnd else LastParseStart) }
    }

    public mutable PreviousTextSize : int;

    public PreviousText : string
    {
      get
      {
        when (PreviousTextSize <= 0)
          PreviousTextSize = 20;

        def pos = if (LastParseEnd >= 0) LastParseEnd else LastParseStart;
        if (pos >= PreviousTextSize)
          Text.Substring(pos - PreviousTextSize, PreviousTextSize)
        else
          Text.Substring(0, pos)
      }
    }

    public Allocate(size : int) : int
    {
      def newAst = allocated;
      allocated = allocated + size;
      while (ast.Length <= allocated)
        Array.Resize(ref ast, (ast.Length * 3) / 2);

      newAst
    }

    public Allocate(size : int, ruleId : int) : int
    {
      def newAst = Allocate(size);
      ast[newAst] = ruleId;
      newAst;
    }

    public TryGetPrefix(pos : ref int, prefixAst : ref int) : int
    {
      mutable bestResult = ast[prefixAst + ExtensibleRuleParser.PrefixOfs.List];
      when (bestResult < 0)
      {
        def error = ErrorData[~bestResult];
        when (error.Skip.Length == 0)
          return -1;//правило восстановилось пустым.
        pos += error.Skip.Length; // грязь
        prefixAst = GetAst(pos, ast[prefixAst + ExtensibleRuleParser.PrefixOfs.Id] & ExtensibleRuleParser.AstMask.Id);
        bestResult = ast[prefixAst + ExtensibleRuleParser.PrefixOfs.List]; // исходная ссылка на AST
        assert3(bestResult >= 0 || ErrorData[~bestResult].Skip.Length == 0);
        when (bestResult == 0)
          bestResult = -1;
      }
      bestResult;
    }

    public TryGetPostfix(pos : ref int, postfixAst : ref int) : int
    {
      mutable bestResult = ast[postfixAst + ExtensibleRuleParser.PostfixOfs.List];
      when (bestResult < 0)
      {
        def error = ErrorData[~bestResult];
        when (error.Skip.Length == 0)
          return -1;//правило восстановилось пустым.
        pos += error.Skip.Length; // грязь
        postfixAst = GetAst(pos, ast[postfixAst + ExtensibleRuleParser.PostfixOfs.Id] & ExtensibleRuleParser.AstMask.Id);
        bestResult = ast[postfixAst + ExtensibleRuleParser.PostfixOfs.List]; // исходная ссылка на AST
        assert3(bestResult >= 0 || ErrorData[~bestResult].Skip.Length == 0);
        when (bestResult == 0)
          bestResult = -1;
      }
      bestResult;
    }

    public TryGetAst(pos : int, ruleId : int) : int
    {
      for (mutable astPtr = memoize[pos]; astPtr > 0; astPtr = ast[astPtr + ExtensibleRuleParser.AstOfs.Next])
        when (ast[astPtr] == ruleId)
          return astPtr;
      0;
    }

    public GetAst(pos : int, ruleId : int) : int
    {
      def astPtr = TryGetAst(pos, ruleId);
      assert3(astPtr > 0);
      astPtr;
    }

    public GetSize(sizePos : int) : int
    {
      def size = ast[sizePos];
      if (size >= 0)
        size
      else if (size == int.MinValue)
        0
      else
      {
        def error = ErrorData[~size];
        error.Skip.Length + error.Data
      }
    }

    public GetSkip(sizePos : int) : int
    {
      def size = ast[sizePos];
      if (size >= 0)
        0
      else if (size == int.MinValue)
        0
      else
      {
        def error = ErrorData[~size];
        error.Skip.Length
      }
    }

    public GetSkipAndSize(sizePos : int) : int * int
    {
      def size = ast[sizePos];
      if (size >= 0)
        (0, size)
      else if (size == int.MinValue)
        (0, 0)
      else
      {
        def error = ErrorData[~size];
        (error.Skip.Length, error.Data)
      }
    }

    public GetSkipAndSize2(sizePos : int) : int
    {
      def size = ast[sizePos];
      if (size >= 0)
        size
      else if (size == int.MinValue)
        0
      else
      {
        def error = ErrorData[~size];
        ~(error.Skip.Length + error.Data)
      }
    }

    public AstSize(astPtr : int, begin : int, end : int) : int
    {
      mutable size = 0;
      def end = astPtr + end;
      for (mutable i = astPtr + begin; i < end; ++i)
        size += GetSize(i);
      size;
    }

    public PatchAst(ruleParser : IRecoveryRuleParser, astPtr : int, errorIndex : int, astFailState : int, failState : int, startState : int) : void
    {
      when (astFailState < failState)
      {
        mutable subrule = astPtr + ruleParser.GetOffsetForState(astFailState);
        for (mutable state = astFailState; state != failState; state = ruleParser.GetNextState(state))
        {
          ast[subrule] = int.MinValue;
          ++subrule;
        }
      }
      if (startState == -2)
        ast[astPtr + ExtensibleRuleParser.AstOfs.State] = ~failState;
      else
      {
        if (startState >= 0)
          ast[astPtr + ExtensibleRuleParser.AstOfs.State] = ~startState;
        else
          ast[astPtr + ExtensibleRuleParser.AstOfs.State] = AstParsedState;
        mutable subrule = astPtr + ruleParser.GetOffsetForState(failState);
        ast[subrule] = ~errorIndex;
        ++subrule;
        for (mutable state = ruleParser.GetNextState(failState); state != startState; state = ruleParser.GetNextState(state))
        {
          ast[subrule] = int.MinValue;
          ++subrule;
        }
      }
    }

    private delegate SimpleAstCreate(pos : ref int, parseResult : ParseResult) : Ast;
    private static SimpleAstCreateSignature : array[Type] = array[typeof(int).MakeByRefType(), typeof(ParseResult)];

    private delegate ExtensibleAstCreate(pos : ref int, parseResult : ParseResult, bindingPower : int, ruleDescriptor : ExtensibleRuleDescriptor) : Ast;
    private static ExtensibleAstCreateSignature : array[Type] = array[typeof(int).MakeByRefType(), typeof(ParseResult), typeof(int), typeof(ExtensibleRuleDescriptor)];

    public CreateAst() : Nitra.Ast
    {
      //FIXME: rewrite without reflection
      def astType = ReflectionHelper.GetBaseAstType(this.RuleParser.Descriptor);
      match (this.RuleParser.Descriptor)
      {
        | SimpleRuleDescriptor =>
          def astCreateMethod = astType.GetMethod("Create", SimpleAstCreateSignature);
          def astCreate       = Delegate.CreateDelegate(typeof(SimpleAstCreate), astCreateMethod) :> SimpleAstCreate;
          mutable pos = StartPos;
          astCreate(ref pos, this)

        | ExtensibleRuleDescriptor as descriptor =>
          def astCreateMethod = typeof(ExtensibleRuleAstConstructor[_]).MakeGenericType(astType).GetMethod("Create", ExtensibleAstCreateSignature);
          def astCreate       = Delegate.CreateDelegate(typeof(ExtensibleAstCreate), astCreateMethod) :> ExtensibleAstCreate;
          mutable pos = StartPos;
          astCreate(ref pos, this, 0, descriptor)

        | _ => assert(false)
      }
    }

    public GetSpans(startPos : int, endPos : int, spans : SCG.List[SpanInfo]) : void
    {
      def walkerHost = this.ParserHost.GetWalkerHost(StandardWalkerTypes.Highlighter);
      def start_Walker = walkerHost.GetRootWalker(this);
      mutable pos = 0;
      _ = late start_Walker.Walk(ref pos, this, spans, startPos, endPos);
    }

    public GetOutlining(outlining : SCG.List[OutliningInfo]) : void
    {
      def walker = Outlining.OutliningWalker();
      _ = walker.Walk(this, outlining);
    }

    public Reflect() : ReflectionStruct
    {
      def nodes = SCG.List();
      def walker = ReflectionWalker();
      _ = walker.Walk(this, nodes);
      // FIXME: этот код должен быть в волкере
      ReflectionStruct(RuleParser.Descriptor.Name, NSpan(StartPos, ast[ParseResult.ResultOffset]), ReadOnlyCollection(nodes.ToArray()))
    }

    public ReportError(error : ParseError) : void
    {
      _errors.Add(error);
    }
    
    public GetErrors() : array[Error]
    {
      _errors.ToArray()
    }

    public GetRuleParser(astPtr : int) : object
    {
      def ruleId = this.ast[astPtr] & ExtensibleRuleParser.AstMask.Id;
      this.ParserHost.RuleParsers[ruleId]
    }

    public GetSequenceInfo(astPtr : int) : SequenceInfo
    {
      def ruleId = this.ast[astPtr] & ExtensibleRuleParser.AstMask.Id;
      (this.ParserHost.RuleParsers[ruleId] :> IRuleParserReflection).Reflection(ruleId)
    }

    public GetGarbage(prevPos : int, pos : int) : NSpan
    {
      def cmp(e)
      {
        if (e.Skip.StartPos < prevPos)
          -1
        else
          if (e.Skip.EndPos >= pos)
            1
          else
            0
      }
      def errorIndex = ErrorData.BinarySearch(cmp);
      if (errorIndex >= 0)
      {
        def error = ErrorData[errorIndex];
        error.Skip
      }
      else
        NSpan()
    }

    private GetSource() : SourceSnapshot implements ISourceSnapshotProvider.GetSource
    {
      OriginalSource
    }
  }
}
