using System.Reflection;
using Nitra.Internal;
using Nemerle;
using Nemerle.Collections;
using Nemerle.Imperative;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;

public module X
{
  public VisualizeFrame(frame : RecoveryStackFrame) : void
  {
    VisualizeFrames([frame])
  }

  public VisualizeFrames(stacks : Seq[RecoveryStackFrame]) : void
  {
    def dot = Nitra.Internal.RecoveryStackFrame.DotStacks(stacks);
    ExecuteDot(dot);
  }

  public VisualizeFrames(stacks : Seq[ParseAlternativeNode]) : void
  {
    def dot = Nitra.Internal.ParseAlternativeNode.DotNodes(stacks);
    ExecuteDot(dot);
  }

  public VisualizeRecoveryResults(results : Seq[RecoveryResult]) : void
  {
    VisualizeFrames(results.Map(r => r.Stack))
  }

  public VisualizeRecoveryParser(recoveryParser : RecoveryParser) : void
  {
    def (toOpen, sources) = recoveryParser.ToDot(0);
    when (sources.Count > 0)
      ExecuteDot(toOpen, sources);
  }

  static ToolsDir = "ExternalTools";

  private ExecuteDot(source : string) : void
  {
    def dotFileName = Path.ChangeExtension(Path.GetTempFileName(), "dot");
    File.WriteAllText(dotFileName, source);
    def svgFileName = Path.ChangeExtension(dotFileName, "svg");
    def process = Process.Start(FindDotExe(), $<#$dotFileName -o $svgFileName -Tsvg#>);
    process.WaitForExit();
    _ = Process.Start(svgFileName);
  }

  private ExecuteDot(filesToOpen : List[string], sources : Dictionary[string, string]) : void
  {
    def sourcesDir = Directory.CreateDirectory(Path.ChangeExtension(Path.GetTempFileName(), null));
    def sourceFileNames = System.Collections.Generic.Queue();
    foreach (p with (name = p.Key, text = p.Value) in sources)
    {
      def fileName = Path.Combine(sourcesDir.FullName, name);
      File.WriteAllText(fileName, text);
      sourceFileNames.Enqueue(fileName);
    }

    while (sourceFileNames.Count > 0)
    {
      def batchSize = 20;
      def sourceFileNamesBatch = List(batchSize);
      for (mutable i; i < batchSize && sourceFileNames.Count > 0; ++i)
        sourceFileNamesBatch.Add(sourceFileNames.Dequeue());

      def si = ProcessStartInfo();
      si.FileName = FindDotExe();
      si.Arguments = $<#-Tsvg -O ..$(sourceFileNamesBatch; " ")#>;

      using (process = Process.Start(si))
        process.WaitForExit();
    }

    foreach (name in filesToOpen)
    {
      def fileName = Path.Combine(sourcesDir.FullName, name + ".svg");
      Process.Start(fileName).Dispose();
    }
  }

  private FindDotExe() : string
  {
    def dir = Path.GetDirectoryName(Path.GetFullPath(Assembly.GetExecutingAssembly().Location));
    def findDot(dir : string) : string
    {
      if (Directory.Exists(Path.Combine(dir, ToolsDir)))
        Path.Combine(dir, ToolsDir, @"DOT\dot.exe")
      else
      {
        def parent = Directory.GetParent(dir);
        if (parent == null)
          null
        else
          findDot(parent.FullName)
      }
    }
    
    findDot(dir)
  }
  
  public static SafeLeftSubstring(this str : string, pos : int, len : int) : string
  {
    assert3(pos >= 0);
    when (pos == 0)
      return "";
      
    // "1234■12345
    if (pos <= len)
      str.Substring(0, pos)
    else
      str.Substring(pos - len, if (pos > str.Length) str.Length - (pos - len) else len)
  }

  public static SafeRightSubstring(this str : string, pos : int, len : int) : string
  {
    str.Substring(pos, if (pos + len > str.Length) str.Length - pos else len)
  }
}
